
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useApp } from "@/context/AppContext";
import { Fund } from "@/types";
import { useState, useMemo, useRef, useEffect } from "react";
import { MinusIcon, PlusIcon, RefreshCwIcon, SparklesIcon, CheckIcon, XIcon } from "lucide-react";
import { toast } from "sonner";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { cn, formatNumberWithSeparators, numberToVietnameseText } from "@/lib/utils";
import { parseTransactionWithLLM, LLMTransactionResponse } from "@/services/aiService";
import { getAIPromptsForFund } from "@/services/aiPromptStorage";
import { TransactionFormValidator, ValidationError } from "@/services/TransactionFormValidator";
import { ValidationWarning } from "@/components/ui/validation-warning";

interface CreateTransactionSheetProps {
  fund: Fund;
  children: React.ReactNode;
  initialData?: {
    description?: string;
    amount?: string;
    paidBy?: string;
    splits?: { userId: string; amount: number }[];
    reasoning?: string; // Add reasoning field
    aiGenerated?: boolean; // Flag to indicate if this was generated by AI
    aiPrompt?: string; // The original AI prompt used to generate this transaction
  };
  openSheet?: boolean;
  onOpenChange?: (open: boolean) => void;
}

// No need for timing constants anymore with effect-based architecture

/**
 * CreateTransactionSheet component for creating new transactions
 * Supports both manual creation and AI-assisted transaction creation
 */
export function CreateTransactionSheet({ fund, children, initialData, openSheet, onOpenChange }: CreateTransactionSheetProps) {
  const { createTransaction, currentUser, getUserById, loadUserFunds, funds } = useApp();
  const [description, setDescription] = useState(initialData?.description || "");
  const [amount, setAmount] = useState(initialData?.amount || "");
  const [isOpen, setIsOpen] = useState(openSheet || false);
  const [localFund, setLocalFund] = useState(fund);
  const [isReprocessingAI, setIsReprocessingAI] = useState(false);
  const [aiPrompt, setAiPrompt] = useState(initialData?.aiPrompt || "");
  const [splits, setSplits] = useState<{ userId: string; amount: number }[]>([]);
  const [showDescriptionPresets, setShowDescriptionPresets] = useState(false);
  const descriptionInputRef = useRef<HTMLInputElement>(null);
  const [editingSplitUserId, setEditingSplitUserId] = useState<string | null>(null);
  const [editingSplitValue, setEditingSplitValue] = useState<string>("");
  
  // Validation state
  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);
  const [showValidation, setShowValidation] = useState(false);
  const [lastValidatedAt, setLastValidatedAt] = useState<number>(0);
  
  // Create validator instance
  const validatorRef = useRef<TransactionFormValidator | null>(null);

  // Handle fund changes
  useEffect(() => {
    setLocalFund(fund);
  }, [fund]);
  
  // References to prevent circular updates
  const isHandlingOpenChangeRef = useRef(false);
  const hasInitializedRef = useRef(false);
  const initialDataIdRef = useRef<string>("");

  // Debug effect to log state changes
  useEffect(() => {
    console.log("Sheet state updated - isOpen:", isOpen);
  }, [isOpen]);

  // Handle sheet open/close transitions
  // This hook runs on mount and when openSheet changes
  // It sets up the initial state and ensures we reset properly on close
  useEffect(() => {
    // Skip if undefined (uncontrolled component)
    if (openSheet === undefined) return;
    
    // Only update internal state if it differs from the prop
    if (openSheet !== isOpen) {
      console.log("openSheet prop changed to:", openSheet, "(was:", isOpen, ")");
      setIsOpen(openSheet || false);
      
      // Refresh fund data when sheet is opened
      if (openSheet && currentUser) {
        loadUserFunds(currentUser.id);
      }
    }
  }, [openSheet, currentUser, loadUserFunds, isOpen]);

  // Separate effect to update localFund when fund changes, but only once per fund change
  useEffect(() => {
    setLocalFund(fund);
  }, [fund.id]);
  
  // Convert member IDs to user objects
  const memberUsers = useMemo(() => {
    return (localFund.members || []).map(memberId => {
      const user = getUserById(memberId);
      return user || {
        id: memberId,
        displayName: 'User',
        email: '',
        photoURL: ''
      };
    });
  }, [localFund.members, getUserById]);
  
  // Initialize validator when member users change
  useEffect(() => {
    if (memberUsers.length > 0) {
      validatorRef.current = new TransactionFormValidator(memberUsers);
    }
  }, [memberUsers]);
  
  // Validate form function
  const validateForm = (options?: { showErrors?: boolean, forceUpdate?: boolean }) => {
    const showErrors = options?.showErrors ?? true;
    const forceUpdate = options?.forceUpdate ?? false;
    
    // Skip validation if no validator or if we've validated recently (unless forced)
    const now = Date.now();
    if (!validatorRef.current || (!forceUpdate && now - lastValidatedAt < 500)) {
      return validationErrors.length === 0;
    }
    
    // Perform validation
    const errors = validatorRef.current.validateForm(description, amount, splits);
    
    // Update state if errors changed or if forced
    if (forceUpdate || JSON.stringify(errors) !== JSON.stringify(validationErrors)) {
      setValidationErrors(errors);
      setLastValidatedAt(now);
      
      if (showErrors && errors.length > 0) {
        setShowValidation(true);
      } 
    }
    
    return errors.length === 0;
  };

  const handleResetForm = () => {
    setDescription("");
    setAmount("");
    setSplits([]);
    setAiPrompt("");
    setValidationErrors([]);
    setShowValidation(false);
  };
  
  /**
   * Process an AI prompt to generate transaction details
   * This is a utility function with no side effects except updating state
   */
  const processAIPrompt = async (prompt: string, currentUserId: string): Promise<boolean> => {
    try {
      // Get member users from fund
      const memberUsers = localFund.members.map(id => {
        const user = getUserById(id);
        return user || { id, displayName: 'Unknown', email: '', photoURL: '' };
      });
      
      // Call the AI service to parse the transaction
      const result = await parseTransactionWithLLM(
        prompt, 
        localFund, 
        memberUsers,
        currentUserId
      );
      
      console.log("AI results received:", result);
      
      // Update form with results
      updateFormWithAIResults(result);
      return true;
    } catch (error) {
      // Handle errors and show helpful messages
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Không thể xử lý yêu cầu';
      
      toast.error(errorMessage, {
        duration: 5000,
        description: 'Vui lòng thử lại với mô tả chi tiết hơn'
      });
      return false;
    }
  };
  
  // Update form with AI results - single responsibility function
  const updateFormWithAIResults = (result: LLMTransactionResponse) => {
    // Update the form with the new AI results
    setDescription(result.desc || description);
    setAmount(result.totalAmount.toString());
    
    // Update splits with the new amounts
    const newSplits = localFund.members.map(memberId => {
      const amountStr = result.users[memberId];
      const amount = amountStr ? parseInt(amountStr) : 0;
      return { userId: memberId, amount };
    });
    
    setSplits(newSplits);
    
    // Update the reasoning field in the initialData object if possible
    if (initialData) {
      initialData.reasoning = result.reasoning;
    }
    
    // Validate the AI-generated transaction after a short delay
    // to allow state updates to complete
    setTimeout(() => {
      const isValid = validateForm({ showErrors: true, forceUpdate: true });
      
      if (isValid) {
        toast.success("Đã cập nhật kết quả AI", {
          description: "Giao dịch đã được cập nhật với kết quả mới từ AI"
        });
      } else {
        toast.warning("Kết quả AI có thể cần điều chỉnh", {
          description: "Vui lòng kiểm tra các lỗi được hiển thị"
        });
        
        // Scroll to the top where errors are displayed
        const contentElement = document.querySelector('.transaction-form-content');
        if (contentElement) {
          contentElement.scrollTop = 0;
        }
      }
    }, 300);
  };

  // Handler for the AI rerun button
  const handleRerunAI = async (e: React.MouseEvent<HTMLButtonElement>) => {
    // Prevent event bubbling to avoid form submission
    e.preventDefault();
    e.stopPropagation();
    
    if (!aiPrompt || isReprocessingAI || !currentUser) {
      toast.error("Không thể xử lý", { description: "Thiếu thông tin AI cần thiết" });
      return;
    }
    
    setIsReprocessingAI(true);
    console.log("Re-running AI with prompt:", aiPrompt);
    
    try {
      await processAIPrompt(aiPrompt, currentUser.id);
    } finally {
      setIsReprocessingAI(false);
    }
  };

  // Initialize form data from initialData prop
  const initializeFormData = (data: CreateTransactionSheetProps['initialData']) => {
    if (!data) return;
    
    console.log("Initializing form data:", data);
    // Apply data values with safety checks
    if (data.description) setDescription(data.description);
    if (data.amount) setAmount(data.amount);
    if (data.aiPrompt) setAiPrompt(data.aiPrompt);
    
    // Initialize splits with validated data
    if (data.splits && data.splits.length > 0) {
      // Ensure splits are properly formed
      const validSplits = data.splits.map(split => ({
        userId: split.userId,
        amount: typeof split.amount === 'number' ? split.amount : 0
      }));
      console.log("Setting valid splits:", validSplits);
      setSplits(validSplits);
    } else if (localFund.members.length > 0) {
      // Fallback to initialize empty splits if none provided
      const initialSplits = localFund.members.map(memberId => ({
        userId: memberId,
        amount: 0,
      }));
      setSplits(initialSplits);
    }
  };
  
  // Handler for sheet open state changes - single responsibility
  // State tracking for sheet closing - this helps coordinate the reset logic
  const [isClosing, setIsClosing] = useState(false);
  
  // Core handler for sheet open state changes - now just updates state flags
  const handleSheetOpenChange = (open: boolean) => {
    console.log("Sheet open state changing to:", open);
    
    // Set flag to prevent circular updates
    isHandlingOpenChangeRef.current = true;
    
    try {
      // Critical fix: Always notify parent first before changing local state
      // This ensures proper synchronization between parent and child components
      if (onOpenChange) {
        console.log("Notifying parent of sheet state change to:", open);
        onOpenChange(open);
      }
      
      if (!open) {
        // When closing - first set isClosing flag to true
        // An effect will watch this and handle form reset after state update
        setIsClosing(true);
        
        // Reset initialization status when closing
        hasInitializedRef.current = false;
      }
      
      // Always update the internal open state after parent notification
      setIsOpen(open);
    } finally {
      // Clear the flag after a short delay to allow state updates to process
      setTimeout(() => {
        isHandlingOpenChangeRef.current = false;
      }, 0);
    }
  };
  
  // Effect to handle sheet opening logic
  useEffect(() => {
    // Only run on sheet opening (not initial render)
    if (isOpen) {
      console.log("Effect: Sheet is open, initializing data");
      
      // Reset form on open before applying new data
      handleResetForm();
      
      // Apply initial data if available
      if (initialData) {
        initializeFormData(initialData);
        console.log("Initial data applied:", initialData);
        // Explicitly set aiPrompt from initialData to ensure it's always set
        if (initialData.aiPrompt) {
          console.log("Setting aiPrompt from initialData:", initialData.aiPrompt);
          setAiPrompt(initialData.aiPrompt);
        }
      } else if (localFund.members.length > 0) {
        // No initial data - initialize empty splits
        const initialSplits = localFund.members.map(memberId => ({
          userId: memberId,
          amount: 0,
        }));
        setSplits(initialSplits);
      }
      
      // Validate the form after a short delay to allow state updates to complete
      setTimeout(() => {
        validateForm({ showErrors: false });
      }, 500);
    }
  }, [isOpen, initialData, localFund.members]);
  
  // Effect to handle sheet closing logic
  useEffect(() => {
    if (isClosing) {
      console.log("Effect: Sheet is closing, resetting form");
      // Reset form when closing
      handleResetForm();
      // Reset validation state
      setValidationErrors([]);
      setShowValidation(false);
      setLastValidatedAt(0);
      // Reset the flag
      setIsClosing(false);
    }
  }, [isClosing]);

  const handleAmountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let value = e.target.value;
    
    // Allow negative sign at the beginning and digits
    value = value.replace(/[^-\d]/g, '');
    
    // Only allow one negative sign at the beginning
    if (value.startsWith('-')) {
      // Remove any additional negative signs
      const digits = value.substring(1).replace(/-/g, '');
      value = '-' + digits;
    } else {
      // Just keep digits if not negative
      value = value.replace(/-/g, '');
    }
    
    // Validate the input
    if (/^-?\d*$/.test(value)) {
      setAmount(value);
      
      // Update splits with the new amount if they exist
      if (splits.length > 0 && value) {
        // Reset splits to zero when amount changes
        const resetSplits = splits.map(split => ({
          userId: split.userId,
          amount: 0
        }));
        setSplits(resetSplits);
      }
      
      // Validate after a short delay to avoid excessive validation during typing
      setTimeout(() => {
        validateForm({ showErrors: false });
      }, 500);
    }
  };
  
  // Add zeros to the end of the amount (e.g., for quick entry of thousands)
  const addZeros = (count: number) => {
    if (!amount) {
      setAmount('0'.repeat(count));
      return;
    }
    
    setAmount(prev => prev + '0'.repeat(count));
  };
  
  // Set a preset amount
  const setPresetAmount = (value: number) => {
    setAmount(value.toString());
  };
  
  // Format the amount as currency while user is typing
  const formatAmountForDisplay = (value: string) => {
    if (!value) return '';
    
    // Parse the numeric value, preserving negative sign
    const isNegative = value.startsWith('-');
    const numericValue = parseInt(value);
    if (isNaN(numericValue)) return '';
    
    // Format with thousand separators, preserving negative sign
    return formatNumberWithSeparators(numericValue);
  };

  const distributeEvenly = () => {
    if (!amount || !currentUser) return;
    
    const numMembers = localFund.members.length;
    const totalAmount = parseInt(amount);
    
    if (!totalAmount || numMembers <= 1) return;
    
    // Calculate share per member (everyone gets an equal share)
    const sharePerMember = Math.floor(totalAmount / numMembers);
    
    // Calculate remainder to ensure the total is exact
    const remainder = totalAmount - (sharePerMember * numMembers);
    
    // Create new splits with:
    // 1. Everyone (including payer) owing their fair share (negative)
    // 2. The payer also getting credited for what they paid (positive)
    const newSplits = localFund.members.map((memberId, index) => {
      // Everyone has a negative share representing what they owe
      const share = -(sharePerMember + (index === 0 ? remainder : 0)); // Add remainder to first member
      
      if (memberId === currentUser.id) {
        // For the payer: they paid the total amount but also owe their share
        // So their net amount is: totalAmount + their share (which is negative)
        return {
          userId: memberId,
          amount: totalAmount + share
        };
      } else {
        // For everyone else: they just owe their share
        return {
          userId: memberId,
          amount: share
        };
      }
    });
    
    setSplits(newSplits);
    
    // Validate after distributing
    setTimeout(() => {
      validateForm({ showErrors: false });
    }, 300);
  };

  const handleUpdateSplit = (userId: string, value: number) => {
    console.log("handleUpdateSplit:", userId, value);
    setSplits(prev => 
      prev.map(split => 
        split.userId === userId 
          ? { ...split, amount: value } 
          : split
      )
    );
    
    // Validate after a short delay to avoid excessive validation during quick changes
    setTimeout(() => {
      validateForm({ showErrors: false });
    }, 500);
  };

  const startEditingSplit = (userId: string) => {
    const split = splits.find(s => s.userId === userId);
    setEditingSplitUserId(userId);
    // Preserve negative numbers
    const amountStr = split?.amount.toString() || '0';
    setEditingSplitValue(amountStr);
  };

  const saveEditingSplit = () => {
    if (editingSplitUserId && editingSplitValue) {
      const currentSplit = splits.find(s => s.userId === editingSplitUserId);
      if (currentSplit) {
        // Preserve the sign (positive or negative) of the original amount
        const isNegative = currentSplit.amount < 0;
        const newValue = parseInt(editingSplitValue) || 0;
        handleUpdateSplit(editingSplitUserId, isNegative ? -newValue : newValue);
        
        // Validate after saving the split
        setTimeout(() => {
          validateForm({ showErrors: false });
        }, 300);
      }
    }
    cancelEditingSplit();
  };

  const cancelEditingSplit = () => {
    setEditingSplitUserId(null);
    setEditingSplitValue("");
  };

  const handleEditingSplitChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const isCurrentlyNegative = editingSplitValue.startsWith('-');
    // Only allow digits in the input field, since the negative sign is shown outside
    let value = e.target.value.replace(/[^\d]/g, '');
    
    // Preserve the negative sign if it was already negative
    if (isCurrentlyNegative) {
      value = '-' + value;
    }
    
    // Only update if it's a valid number or empty
    if (/^-?\d*$/.test(value)) {
      setEditingSplitValue(value);
    }
  };

  // Add a toggle for negative/positive value
  const toggleSplitValueSign = () => {
    if (!editingSplitValue) return;
    
    if (editingSplitValue.startsWith('-')) {
      setEditingSplitValue(editingSplitValue.substring(1));
    } else {
      setEditingSplitValue('-' + editingSplitValue);
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Force validation with errors shown
    const isValid = validateForm({ showErrors: true, forceUpdate: true });
    
    if (!isValid) {
      // Scroll to the top where errors are displayed
      const contentElement = document.querySelector('.transaction-form-content');
      if (contentElement) {
        contentElement.scrollTop = 0;
      }
      return;
    }
    
    if (!currentUser || !amount) {
      return; // This should be caught by validation
    }
    
    const totalAmount = parseInt(amount);
    
    // If splits are all zero, distribute evenly first
    const allZero = splits.every(split => split.amount === 0);
    if (allZero) {
      distributeEvenly();
      toast.info("Đã tự động chia đều số tiền");
      return; // Return to let the user review the distribution before submitting
    }
    
    createTransaction({
      fundId: fund.id,
      description: description || "Giao dịch mới",
      amount: totalAmount,
      paidBy: currentUser.id,
      splits
    });
    
    // First notify parent of closure before updating local state
    if (onOpenChange) {
      onOpenChange(false);
    }
    
    // Then update local state
    setIsOpen(false);
    handleResetForm();
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat("vi-VN", {
      style: "currency",
      currency: "VND",
      maximumFractionDigits: 0
    }).format(amount);
  };
  
  // Format large numbers with proper thousand separators
  const formatNumber = (amount: number) => {
    return new Intl.NumberFormat("vi-VN", {
      maximumFractionDigits: 0
    }).format(amount);
  };

  // Remove excessive logging

  // Effect to apply initialData when it changes while the sheet is open
  useEffect(() => {
    // Generate a unique ID for this initialData to detect real changes
    const currentDataId = initialData ? JSON.stringify(initialData) : "";
    
    // Only update if sheet is open, we have new initialData, and we're not closing
    if (isOpen && initialData && !isClosing) {
      console.log("Effect: initialData check - already initialized:", hasInitializedRef.current);
      
      // Only initialize if we haven't done so already OR if initialData has genuinely changed
      if (!hasInitializedRef.current || currentDataId !== initialDataIdRef.current) {
        console.log("Initializing form with data, splits length:", splits.length);
        handleResetForm();
        initializeFormData(initialData);
        
        // Mark as initialized and store the current data ID
        hasInitializedRef.current = true;
        initialDataIdRef.current = currentDataId;
      }
    }
    
    // Reset initialization flag when sheet closes
    if (!isOpen) {
      hasInitializedRef.current = false;
    }
  }, [initialData, isOpen, isClosing]);

  return (
    <Sheet 
      open={isOpen} 
      onOpenChange={handleSheetOpenChange}
      defaultOpen={false}
    >
      <SheetTrigger asChild>
        {children}
      </SheetTrigger>
      <SheetContent className="w-full sm:max-w-md flex flex-col h-[100dvh] p-0 overflow-hidden border-l-0 sm:border-l">
        <div className="px-6 pt-6 pb-2 border-b">
          <SheetHeader>
            <SheetTitle>Thêm giao dịch mới</SheetTitle>
            <SheetDescription>
              Thêm một khoản chi tiêu mới vào quỹ {fund.name}
            </SheetDescription>
          </SheetHeader>
        </div>
        <form onSubmit={handleSubmit} className="flex flex-col h-full">
          <div className="flex-1 overflow-y-auto px-6 py-6 space-y-8 transaction-form-content" style={{ maxHeight: 'calc(100vh - 180px)', paddingBottom: '120px' }}>
            {/* Validation errors display */}
            {showValidation && validationErrors.length > 0 && (
              <ValidationWarning 
                errors={validationErrors} 
                onDismiss={() => setShowValidation(false)}
                className="sticky top-0 z-20"
              />
            )}
          <div className="space-y-2">
            <div className="flex justify-between items-center sticky top-0 z-10 bg-background pb-1">
              <Label htmlFor="description">Mô tả</Label>
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="h-6 text-xs"
                onClick={() => setShowDescriptionPresets(!showDescriptionPresets)}
              >
                Gợi ý
              </Button>
            </div>
            <div className="relative">
              <Input
                id="description"
                placeholder="Nhập mô tả giao dịch"
                value={description}
                onChange={(e) => {
                  setDescription(e.target.value);
                  // Validate after a short delay to avoid excessive validation during typing
                  setTimeout(() => {
                    validateForm({ showErrors: false });
                  }, 500);
                }}
                ref={descriptionInputRef}
              />
              
              {/* Description presets */}
              {showDescriptionPresets && (
                <div className="absolute z-10 mt-1 w-full bg-background border rounded-md shadow-lg p-2 space-y-1">
                  <div className="text-xs font-medium text-muted-foreground mb-2">Chọn mô tả phổ biến:</div>
                  {[
                    "Trả nợ",
                    "Chia tiền ăn trưa",
                    "Chia tiền ăn sáng",
                    "Chia tiền ăn tối",
                    "Tiền xăng xe",
                    "Tiền taxi/grab",
                    "Tiền cà phê",
                    "Tiền đi chợ",
                    "Tiền điện nước",
                    "Tiền thuê nhà",
                    "Tiền mua sắm",
                    "Tiền giải trí"
                  ].map((preset) => (
                    <div 
                      key={preset} 
                      className="p-2 text-sm hover:bg-accent rounded-md cursor-pointer"
                      onClick={() => {
                        setDescription(preset);
                        setShowDescriptionPresets(false);
                        descriptionInputRef.current?.focus();
                      }}
                    >
                      {preset}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="amount">Số tiền</Label>
            <div className="relative mb-4">
              <Input
                id="amount"
                placeholder="Nhập số tiền"
                value={amount}
                onChange={handleAmountChange}
                inputMode="numeric"
                required
                className="pl-12 h-14 text-right font-medium text-xl"
                style={{ fontSize: '1.25rem', paddingTop: '16px', paddingBottom: '16px' }}
              />
              <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none text-muted-foreground">
                <span className="font-medium">VND</span>
              </div>
            </div>
            
            {/* Amount display in formatted text */}
            {amount && parseInt(amount) !== 0 && (
              <div className="text-sm text-muted-foreground mt-2 space-y-2 p-3 bg-accent/30 rounded-md">
                <div className="font-medium text-base">
                  {amount.startsWith('-') ? '-' : ''}{formatNumberWithSeparators(Math.abs(parseInt(amount)))} VND
                </div>
                <div className="text-xs italic">
                  {numberToVietnameseText(amount)}
                </div>
              </div>
            )}
            
            {/* Quick amount buttons */}
            <div className="grid grid-cols-4 gap-2 mt-3">
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(10000)}
                className="text-xs h-8"
              >
                10.000
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(50000)}
                className="text-xs h-8"
              >
                50.000
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(100000)}
                className="text-xs h-8"
              >
                100.000
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(200000)}
                className="text-xs h-8"
              >
                200.000
              </Button>
            </div>
            
            {/* Additional preset amounts */}
            <div className="grid grid-cols-4 gap-2 mt-1">
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(500000)}
                className="text-xs h-8"
              >
                500.000
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(1000000)}
                className="text-xs h-8"
              >
                1 triệu
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(2000000)}
                className="text-xs h-8"
              >
                2 triệu
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                size="sm" 
                onClick={() => setPresetAmount(5000000)}
                className="text-xs h-8"
              >
                5 triệu
              </Button>
            </div>
            
            {/* Quick zeros buttons */}
            <div className="flex gap-2 mt-1">
              <Button 
                type="button" 
                variant="ghost" 
                size="sm" 
                onClick={() => addZeros(3)}
                className="flex-1 text-xs h-8"
              >
                + 000
              </Button>
              <Button 
                type="button" 
                variant="ghost" 
                size="sm" 
                onClick={() => addZeros(4)}
                className="flex-1 text-xs h-8"
              >
                + 0000
              </Button>
              <Button 
                type="button" 
                variant="ghost" 
                size="sm" 
                onClick={() => addZeros(5)}
                className="flex-1 text-xs h-8"
              >
                + 00000
              </Button>
            </div>
          </div>
          
          <div className="flex justify-between items-center top-0 z-10 bg-background pb-1">
            <Label>Chia tiền</Label>
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={distributeEvenly}
              disabled={!amount || parseInt(amount) <= 0}
            >
              Chia đều
            </Button>
          </div>
          
          <div className="space-y-4 max-h-[35vh] overflow-y-auto pr-1 pb-6 pt-2">
            {memberUsers.map((member) => (
              <div key={member.id} className="flex items-center gap-3 p-3 rounded-lg hover:bg-accent/20 border border-border/20">
                <Avatar className="h-10 w-10">
                  <AvatarImage src={member.photoURL} alt={member.displayName} />
                  <AvatarFallback>{member.displayName.charAt(0)}</AvatarFallback>
                </Avatar>
                
                <div className="flex-1 text-sm">
                  <div className="font-medium text-base">{member.displayName}</div>
                </div>
                
                <div className="flex items-center rounded-md border">
                  <Button
                    type="button"
                    size="icon"
                    variant="ghost"
                    className="h-8 w-8 rounded-none"
                    disabled={!amount || parseInt(amount) <= 0}
                    onClick={() => {
                      const splitIndex = splits.findIndex(s => s.userId === member.id);
                      if (splitIndex >= 0) {
                        const currentAmount = splits[splitIndex].amount;
                        handleUpdateSplit(member.id, currentAmount - 10000);
                      }
                    }}
                  >
                    <MinusIcon className="h-3 w-3" />
                  </Button>
                  <div className="w-24 relative">
                  {editingSplitUserId === member.id ? (
                    <div className="flex flex-col items-center h-auto py-1">
                        <div className={`relative w-full ${editingSplitValue.startsWith('-') ? 'bg-rose-50 dark:bg-rose-950/20' : ''}`}>
                          {editingSplitValue.startsWith('-') && (
                            <div className="absolute left-2 top-0 bottom-0 flex items-center">
                              <span className="text-rose-500 font-bold">-</span>
                            </div>
                          )}
                          <Input
                            type="text"
                            value={editingSplitValue.startsWith('-') ? editingSplitValue.substring(1) : editingSplitValue}
                            onChange={handleEditingSplitChange}
                            className={`h-12 text-center text-sm p-1 mb-2 font-medium ${editingSplitValue.startsWith('-') ? 'text-rose-600 dark:text-rose-400' : ''}`}
                            autoFocus
                            inputMode="numeric"
                            style={{ fontSize: '1.1rem' }}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter') {
                                e.preventDefault();
                                saveEditingSplit();
                              } else if (e.key === 'Escape') {
                                e.preventDefault();
                                cancelEditingSplit();
                              }
                            }}
                          />
                        </div>
                      <div className="flex justify-center w-full mt-2 gap-2">
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          className="h-10 px-3"
                          onClick={toggleSplitValueSign}
                        >
                          <span className="text-xs">{editingSplitValue.startsWith('-') ? "+" : "-"}</span>
                        </Button>
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          className="h-10 px-4"
                          onClick={saveEditingSplit}
                        >
                          <CheckIcon className="h-3 w-3 text-emerald-500 mr-1" />
                          <span className="text-xs">Lưu</span>
                        </Button>
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          className="h-10 px-4"
                          onClick={cancelEditingSplit}
                        >
                          <XIcon className="h-3 w-3 text-rose-500 mr-1" />
                          <span className="text-xs">Hủy</span>
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <div 
                      className={cn(
                        "w-24 text-center text-sm font-medium h-8 flex items-center justify-center cursor-pointer hover:bg-accent/50 rounded-md",
                        splits.find(s => s.userId === member.id)?.amount > 0 ? "text-emerald-500" : 
                        splits.find(s => s.userId === member.id)?.amount < 0 ? "text-rose-500" : ""
                      )}
                      onClick={() => {
                        if (!amount || parseInt(amount) <= 0) return;
                        startEditingSplit(member.id);
                      }}
                    >
                      {formatCurrency(splits.find(s => s.userId === member.id)?.amount || 0)}
                    </div>
                  )}
                </div>
                  <Button
                    type="button"
                    size="icon"
                    variant="ghost"
                    className="h-8 w-8 rounded-none"
                    disabled={!amount || parseInt(amount) <= 0}
                    onClick={() => {
                      const splitIndex = splits.findIndex(s => s.userId === member.id);
                      console.log("splitIndex:", splitIndex);

                      if (splitIndex >= 0) {
                        const currentAmount = splits[splitIndex].amount;
                        handleUpdateSplit(member.id, currentAmount + 10000);
                      } else {
                        console.error("User not found in splits");
                      }
                    }}
                  >
                    <PlusIcon className="h-3 w-3" />
                  </Button>
                </div>
              </div>
            ))}
          </div>
          
          {/* Display AI reasoning and re-run button if available */}
          {initialData?.reasoning && (
            <div className="my-4 p-3 bg-muted/50 border rounded-md max-h-[30vh] overflow-y-auto">
              <div className="flex justify-between items-center sticky top-0 bg-muted/50 py-1">
                <div className="text-sm font-medium">Gợi ý từ AI:</div>
                {initialData.aiGenerated && (
                  <Button 
                    type="button"
                    variant="outline" 
                    size="sm" 
                    className="h-7 gap-1 text-xs" 
                    onClick={(e) => handleRerunAI(e)}
                    disabled={isReprocessingAI || !aiPrompt}
                  >
                    {isReprocessingAI ? (
                      <>
                        <RefreshCwIcon className="h-3 w-3 animate-spin" />
                        <span>Đang xử lý...</span>
                      </>
                    ) : (
                      <>
                        <RefreshCwIcon className="h-3 w-3" />
                        <span>Chạy lại AI</span>
                      </>
                    )}
                  </Button>
                )}
              </div>
              <div className="text-sm text-muted-foreground whitespace-pre-wrap">{initialData.reasoning}</div>
              
              {/* Show original prompt if available */}
              {initialData.aiPrompt && (
                <div className="mt-3 pt-3 border-t border-border/30">
                  <div className="text-xs text-muted-foreground mb-1 flex items-center gap-1">
                    <SparklesIcon className="h-3 w-3" />
                    <span>Prompt gốc:</span>
                  </div>
                  <div className="text-xs italic text-muted-foreground">{initialData.aiPrompt}</div>
                </div>
              )}
            </div>
          )}

          </div>
          <div className="px-6 py-5 border-t mt-auto sticky bottom-0 bg-background z-10 shadow-md">
            <div className="flex justify-between gap-4 mb-3">
              <Button 
                type="button" 
                variant="secondary" 
                onClick={() => {
                  validateForm({ showErrors: true, forceUpdate: true });
                  // Scroll to the top where errors are displayed
                  const contentElement = document.querySelector('.transaction-form-content');
                  if (contentElement) {
                    contentElement.scrollTop = 0;
                  }
                }} 
                className="flex-1 h-10"
              >
                Kiểm tra lỗi
              </Button>
            </div>
            <div className="flex justify-between gap-4">
              <Button type="button" variant="outline" onClick={() => handleSheetOpenChange(false)} className="flex-1 h-12">
                Hủy
              </Button>
              <Button type="submit" disabled={!amount || parseInt(amount) <= 0} className="flex-1 h-12">
                Thêm giao dịch
              </Button>
            </div>
          </div>
        </form>
      </SheetContent>
    </Sheet>
  );
}
